---
layout:     post
title:      汇编基础
date:       2020-01-09
author:     白板
catalog: true
tags: 
    - 汇编
---

# 寄存器类型
- EAX
- EBX
- ECX
- EDX
- EDI
- ESI
- EBP 基址指针寄存器(extended base pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的底部。
- ESP 栈指针寄存器(extended stack pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的栈顶。

# 常用汇编指令

***

指令 LDR(load)

含义：读内存命令

例子：

指令：LDR R0 ,[R1]   --假设R1的值为x

命令解析：读取地址x上的数据（4个字节）保存到R0中。

***

指令：LDR(伪指令)
含义：伪指令（并不存在的指令，最终被解析成真正的汇编指令）

例子：

LDR R0,=0x12345678

命令解析：把0x12345678的值赋值给R0

补充：伪指令的含义

一条ARM指令为 32 位 ，其中肯定是由某些字节来表示MOV本身，
某一位用来指定使用的寄存器（比如R0）,剩下的位就不足32位了，
如果我们需要使用命令：MOV R0 ,#0x12345678 ,此时MOV指令剩下的位已经不足32为了，这条指令就会出错，
所以MOV指令不能写任意值，只能写简单的值（被称为立即数）。

***
指令：STR(Srote)
含义：写内存命令

例子：

指令：LDR R0 ,[R1]   --假设R1的值为x

命令解析：

例子：

指令：STR R0 ,[R1]   --假设R1的值为x

命令解析：把R0的值（4字节）写到地址x中去。
***
指令：ldm
含义：读内存读取数据，然后把读取的数据写入多个寄存器

命令解析：

例子：

ldmia    sp, {fp, sp, pc}

假设：sp=4080

例子：ia的含义是过后增加(Increment After)，就是先读取后增加，而且的顺序的依据是：高编号的寄存器存储在高地址

fp,sp,  pc 这三个的寄存器编号分别如下所示（ARM编程手册查看）

pc->R15,sp->R13,fp->R11.所以存取的顺序是：fp-sp-pc（与指令顺序无关）

***
指令：stm
含义：把多个寄存器的值写入内存

例子：

指令：stmdb    sp!, {fp, ip, lr, pc}

解析：假设sp=4096,db是预先减少(Decrement Before)的意思，就是先减少后存入sp开始的地址，
而且存取的顺序的依据是：高编号的寄存器存储在高地址。fp, ip, lr, pc 这四个的寄存器编号分别如下所示（ARM编程手册查看）

pc->R15,lr->R14,ip->R12,fp->R11.所以存取的顺序是：pc-lr-ip-fp（与顺序无关）

***
指令：B
含义：跳转指令

***
指令：BL
含义：跳转到指定指令,把返回地址(下一条指令的地址)保存在lr寄存里边

例子：

BL  xx

aa

解析：命令跳转到xx处执行，且lr寄存器保存aa的地址，以便继续运行
***
指令：MOV(move)
含义：赋值指令

例子1：

MOV R0，R1 

命令解析：把R1的值赋值给R0

(即为：R0=R1)

例子2：

MOV R0,#0x100

命令解析：把0x100赋值给R0

***
指令：sub
含义：减法指令

例子1：

指令：sub ro ,r1,#5 

解析：其含义是:r0 = r1 -5;

例子2：

指令：sub ro ,r1,r2 

解析：其含义是:r0 = r1 -r2
***
指令：add
含义：加法指令

例子1：

指令：add ro ,r1,#5 

解析：其含义是:r0 = r1 + 5;

指令：add ro ,r1,r2 

解析：其含义是:r0 = r1 + r2;

***
指令：cmp
含义： cmp(compare)指令进行比较两个操作数的大小

例子：例:cmp oprd1,oprd2

其含义为第一个操作减去第二个操作数,但不影响第两个操作数的值,它影响flag的CF，ZF，OF，AF，PF.

若执行指令后:ZF=1,则说明两个数相等，因为zero为1说明结果为0.

   当无符号时：

   若CF=1,则说明了有进位或借位，cmp是进行的减操作，故可以看出为借位，所以，此时oprd1<oprd2;

   CF=0,则说明了无借位，但此时要注意ZF是否为0，若为0，则说明结果不为0，故此时oprd1>oprd2.

   当有符号时：

   若SF=0，OF=0 则说明了此时的值为正数，没有溢出，可以直观的看出，oprd1>oprd2;

   若SF=1，OF=0 则说明了此时的值为负数，没有溢出，则为oprd1<oprd2;

   若SF=0，OF=1 则说明了此时的值为正数，有溢出，可以看出oprd1<oprd2;

   若SF=1，OF=1则说明了此时的值为负数，有溢出，可以看出oprd1>oprd2;

   最后两个可以作出这种判断的原因是，溢出的本质问题：

   两数同为正，相加，值为负，则说明溢出

   两数同为负，相加，值为正，则说明溢出

   故有，正正得负则溢出，负负得正则溢出
***
指令：bne
含义： 是个条件跳转，即:是“不相等(或不为0)跳转指令”。如果不为0就跳转到后面指定的地址，继续执行

例子：

    cmp    r3, #4    ; 0x4

    bne    a0 <led_on+0x48>

    ldr    r2, [fp, #-20]

当着两句连用时，代表r3-4，如果结果为0，则继续执行下面的语句ldr，如果结果不为0,则跳转到<led_on+0x48>地址处执行。

***
指令：MRS
含义：MRS指令用于将程序状态寄存器的内容传送到通用寄存器中。

格式：MRS{条件}   通用寄存器，程序状态寄存器（CPSR或SPSR）

例子：

MRS R0，CPSR  @传送CPSR的内容到R0
MRS R0，SPSR  @传送SPSR的内容到R0
***
指令：bic
含义：BIC指令用于清除（操作数1）的某些位，并把结果放置到目的寄存器中。（操作数1）应是一个寄存器，（操作数2）可以是一个寄存器，被移位的寄存器，或一个立即数。（操作数2）为32位的掩码，如果在掩码中设置了某一位，则清除返一位。未设置的掩码位保持不变。

格式：BIC{条件}{S}  目的寄存器，操作数1，操作数2

例子：
bic r0,r0,#0x1f
0x1f=0xb11111
其含义：清除r0的bit[4:0]位。
***


# 参考
[汇编笔记](http://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html)

[常用汇编语言语法](https://blog.csdn.net/qq_36243942/article/details/84671886)